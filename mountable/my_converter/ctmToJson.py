import json
from pathlib import Path
from optparse import OptionParser
import re
import os
import re
from tqdm.auto import tqdm



parser = OptionParser()
parser.add_option("-m", "--manifest", dest = "manifest", help="Alternative to --timestamps. The nemo manifest used to create the timestamps.", default = None)
parser.add_option("-o", "--output", dest = "output", help = "path for the output files in the style of ibm")


(options, args) = parser.parse_args()

manifestPath = options.manifest
outputPath = options.output

def is_entry_in_all_lines(manifest_filepath, entry):
    """
    Returns True is entry is a key in all of the JSON lines in manifest_filepath.
    """
    with open(manifest_filepath, 'r') as f:
        for line in f:
            data = json.loads(line)

            if entry not in data:
                return False

    return True


if manifestPath is not None:
        manifestLines = Path(manifestPath).read_text().split("\n")
        if not is_entry_in_all_lines(manifestPath, "audio_filepath"):
            raise RuntimeError(
            "At least one line in manifest does not contain an 'audio_filepath' entry. "
            "All lines should contain an 'audio_filepath' entry."
            )
        
        if not is_entry_in_all_lines(manifestPath, "text"):
            raise RuntimeError(
            "At least one line in manifest does not contain an 'text' entry. "
            "All lines should contain an 'text' entry."
            )
        
        if not is_entry_in_all_lines(manifestPath, "word_level_ctm_filepath"):
            raise RuntimeError(
                "At least one line in manifest does not contain an 'word_level_ctm_filepath' entry. "
                "All lines should contain an 'word_level_ctm_filepath' entry."
                "You might have provided a manifest from before the align process."
            )
else:
    raise RuntimeError(
            "Please provide the manifest generated by the align process."
            "Use -m or --manifest"
        )

if outputPath is None:
    raise RuntimeError(
            "Please provide the outputPath."
            "Use -o or --output"
        )

with open(manifestPath, 'r') as manifest_file:
        for manifest_idx, manifest_line in enumerate(tqdm(manifest_file, desc=f"Reading Manifest {manifestPath} ...", ncols=120)):
            data = json.loads(manifest_line)
            word_level_ctm_file_path = data['word_level_ctm_filepath']
            full_text = data['text']
            solutions = []
            ctm_file = open(word_level_ctm_file_path, 'r')
            lines = ctm_file.readlines()
            for line in lines:
                segments = line.split()
                audio_generated_id = segments[0]
                second_value = segments[1]
                start_ts = segments[2]
                duration = segments[3]
                end_ts = float(start_ts)+float(duration)
                word = segments[4]
                solution = {'word': word,
                    'start_time': start_ts,
                    'end_time': end_ts,
                    'confidence': 1} # nvidia nemo doesn't give confidence, so we use a dummy value
                solution['word'] = word
                solutions.append(solution)
                
            ibm_ts_list = []
            for solution in solutions:
                word = solution['word']
                start = solution['start_time']        
                end = solution['end_time']
                package = [word,start,end]
                ibm_ts_list.append(package)     

            ibm_conf_list = []
            for solution in solutions:
                word = solution['word']
                confidence = solution['confidence']
                package = [word,confidence]
                ibm_conf_list.append(package)   

            outputDictionary = [{
                    "result_index" : 0,
                    "results":
                    {
                            "final": [True],
                            "alternatives": [{
                                    "transcript": full_text,
                                    "confidence": 1,
                                    "timestamps": ibm_ts_list,
                                    "word_confidence": ibm_conf_list
                            }],
                            "word_alternatives": [] # we do not provide alternatives, this is just for compatiblity with ibm
                    }
            }]
            outputFileForThis = os.path.basename(word_level_ctm_file_path)
            outputPathForThis = os.path.join(outputPath, outputFileForThis)

            with open(outputPathForThis, "w") as outfile:
                    json.dump(outputDictionary, outfile)

print("Done! Check results in " + outputPath)
